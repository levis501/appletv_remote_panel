# App Chooser Button Sizing: Problem & Solution

## The Problem

The app chooser dialog buttons exhibited a non-deterministic rendering bug: on some opens, the buttons would render at their correct size (89 × 50 px), but on other opens they would collapse to the width of their text labels. This was a true race condition rooted in GNOME Shell's interaction between `Clutter.FlowLayout` (which measures children via `get_preferred_width/height()` callbacks) and the embedded CSS engine (which resolves styles lazily relative to the layout pass). When `FlowLayout` measured a button's preferred size before the CSS engine had flushed the `width`/`min-width` properties, the layout manager would read the button's raw content size (text width) instead of the CSS-declared size, and that undersized allocation was permanent. This timing depended entirely on the state of the GLib event loop at the moment the async `_loadApps()` resumed after fetching apps from the device.

## Why Traditional Fixes Failed

Attempts to solve this with pure CSS (cascade ordering, compound selectors, `!important` declarations) all failed because they still relied on the CSS engine to flush styles before the layout measurement—a race that could never be reliably won. Wrapping buttons in fixed-size containers, using idle callbacks, or forcing `ensure_style()` + `queue_relayout()` each proved flaky, as the fundamental issue was that some layout manager was **always** querying preferred sizes at an unpredictable moment. The solution required bypassing the race entirely: **use `Clutter.FixedLayout` and manually position tiles at exact pixel coordinates**. Since `FixedLayout` never invokes `get_preferred_width/height()`, the CSS timing race is eliminated. Tiles are `St.Button` widgets with size set imperatively via `set_size(89, 50)` and positioned via `set_position(x, y)` in a 3-column grid. This deterministic approach guarantees consistent button sizing across all opens, solving a problem that CSS alone could never reliably fix.
